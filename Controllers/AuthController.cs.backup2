using BCrypt.Net;
using GestionTime.Api.Contracts.Auth;
using GestionTime.Api.Security;
using GestionTime.Infrastructure.Persistence;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using System.Security.Claims;

namespace GestionTime.Api.Controllers;

[ApiController]
[Route("api/v1/auth")]
public class AuthController(
    GestionTimeDbContext db, 
    JwtService jwt, 
    RefreshTokenService refreshSvc,
    ILogger<AuthController> logger) : ControllerBase
{
    [HttpPost("login")]
    public async Task<IActionResult> Login([FromBody] LoginRequest req)
    {
        var email = (req.Email ?? "").Trim().ToLowerInvariant();
        logger.LogInformation("Intento de login para {Email}", email);

        var user = await db.Users
            .Include(u => u.UserRoles).ThenInclude(ur => ur.Role)
            .SingleOrDefaultAsync(u => u.Email == email);

        if (user is null || !user.Enabled)
        {
            logger.LogWarning("Login fallido para {Email}: usuario no encontrado o deshabilitado", email);
            return Unauthorized(new { message = "Credenciales inválidas" });
        }

        bool ok;
        try
        {
            ok = BCrypt.Net.BCrypt.Verify(req.Password, user.PasswordHash);
        }
        catch (BCrypt.Net.SaltParseException ex)
        {
            logger.LogError(ex, "Error de BCrypt al verificar password para {Email}", email);
            ok = false;
        }

        if (!ok)
        {
            logger.LogWarning("Login fallido para {Email}: contraseña incorrecta", email);
            return Unauthorized(new { message = "Credenciales inválidas" });
        }

        var roles = user.UserRoles.Select(ur => ur.Role.Name).ToArray();

        // Access token (JWT)
        var accessToken = jwt.CreateAccessToken(user.Id, user.Email, roles);
        logger.LogDebug("Token de acceso generado para {UserId}", user.Id);

        // Refresh token (raw + hash)
        var (rawRefresh, refreshHash, refreshExpires) = refreshSvc.Create();

        db.RefreshTokens.Add(new GestionTime.Domain.Auth.RefreshToken
        {
            UserId = user.Id,
            TokenHash = refreshHash,
            ExpiresAt = refreshExpires,
            RevokedAt = null
        });

        await db.SaveChangesAsync();

        SetAccessCookie(accessToken);
        SetRefreshCookie(rawRefresh, refreshExpires);

        logger.LogInformation("Login exitoso para {Email} (UserId: {UserId}, Roles: {Roles})", 
            email, user.Id, string.Join(", ", roles));

        return Ok(new { message = "ok" });
    }

    [HttpPost("refresh")]
    public async Task<IActionResult> Refresh()
    {
        if (!Request.Cookies.TryGetValue("refresh_token", out var rawRefresh) || string.IsNullOrWhiteSpace(rawRefresh))
        {
            logger.LogWarning("Intento de refresh sin token");
            return Unauthorized(new { message = "No refresh token" });
        }

        var hash = RefreshTokenService.Hash(rawRefresh);
        logger.LogDebug("Procesando refresh token (hash: {HashPrefix}...)", hash[..8]);

        var token = await db.RefreshTokens
            .Include(t => t.User)
                .ThenInclude(u => u.UserRoles)
                    .ThenInclude(ur => ur.Role)
            .SingleOrDefaultAsync(t => t.TokenHash == hash);

        if (token is null || token.RevokedAt != null || token.ExpiresAt <= DateTime.UtcNow || !token.User.Enabled)
        {
            logger.LogWarning("Refresh token inválido, revocado o expirado");
            return Unauthorized(new { message = "Refresh inválido" });
        }

        // Rotación: revoca el antiguo
        token.RevokedAt = DateTime.UtcNow;

        var roles = token.User.UserRoles.Select(ur => ur.Role.Name).ToArray();
        var newAccess = jwt.CreateAccessToken(token.User.Id, token.User.Email, roles);

        var (newRawRefresh, newHash, newRefreshExpires) = refreshSvc.Create();

        db.RefreshTokens.Add(new GestionTime.Domain.Auth.RefreshToken
        {
            UserId = token.User.Id,
            TokenHash = newHash,
            ExpiresAt = newRefreshExpires,
            RevokedAt = null
        });

        await db.SaveChangesAsync();

        SetAccessCookie(newAccess);
        SetRefreshCookie(newRawRefresh, newRefreshExpires);

        logger.LogInformation("Token refrescado exitosamente para {UserId}", token.User.Id);

        return Ok(new { message = "ok" });
    }

    [Authorize]
    [HttpGet("me")]
    public IActionResult Me()
    {
        var email = User.FindFirst(ClaimTypes.Email)?.Value ?? "unknown";
        var roles = User.Claims.Where(c => c.Type == ClaimTypes.Role).Select(c => c.Value).ToArray();
        
        logger.LogDebug("Consulta /me para {Email}", email);
        
        return Ok(new MeResponse(email, roles));
    }

    [HttpPost("logout")]
    public async Task<IActionResult> Logout()
    {
        var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
        logger.LogInformation("Logout solicitado{UserInfo}", 
            userId != null ? $" por UserId: {userId}" : "");

        // Revoca el refresh actual (si existe)
        if (Request.Cookies.TryGetValue("refresh_token", out var rawRefresh) && !string.IsNullOrWhiteSpace(rawRefresh))
        {
            var hash = RefreshTokenService.Hash(rawRefresh);

            var token = await db.RefreshTokens.SingleOrDefaultAsync(t => t.TokenHash == hash);
            if (token is not null && token.RevokedAt == null)
            {
                token.RevokedAt = DateTime.UtcNow;
                await db.SaveChangesAsync();
                logger.LogDebug("Refresh token revocado");
            }
        }

        Response.Cookies.Delete("access_token");
        Response.Cookies.Delete("refresh_token", new CookieOptions
        {
            Path = "/api/v1/auth/refresh"
        });

        logger.LogInformation("Logout completado");

        return Ok(new { message = "bye" });
    }

    private void SetAccessCookie(string jwtToken)
    {
        Response.Cookies.Append("access_token", jwtToken, new CookieOptions
        {
            HttpOnly = true,
            Secure = true,
            SameSite = SameSiteMode.None,
            Expires = DateTimeOffset.UtcNow.AddMinutes(15),
            Path = "/"
        });
    }

    private void SetRefreshCookie(string refreshRaw, DateTime refreshExpiresUtc)
    {
        Response.Cookies.Append("refresh_token", refreshRaw, new CookieOptions
        {
            HttpOnly = true,
            Secure = true,
            SameSite = SameSiteMode.None,
            Expires = new DateTimeOffset(refreshExpiresUtc),
            Path = "/api/v1/auth/refresh"
        });
    }


// ========================================
// RECUPERACIÓN DE CONTRASEÑA
// ========================================
// 
// IMPORTANTE: Este NO es un archivo compilable.
// Es solo código para COPIAR y PEGAR en AuthController.cs
//
// INSTRUCCIONES:
// 1. Copia TODO este archivo (Ctrl+A, Ctrl+C)
// 2. Abre: C:\GestionTime\src\GestionTime.Api\Controllers\AuthController.cs
// 3. Ve al final del archivo (después de SetRefreshCookie, antes del último })
// 4. Pega el código (Ctrl+V)
// 5. Guarda (Ctrl+S)
// ========================================

[HttpPost("forgot-password")]
[AllowAnonymous]
public async Task<IActionResult> ForgotPassword(
    [FromBody] ForgotPasswordRequest req,
    [FromServices] Services.ResetTokenService resetTokenSvc,
    [FromServices] Services.IEmailService emailSvc)
{
    var email = (req.Email ?? "").Trim().ToLowerInvariant();
    logger.LogInformation("Solicitud de recuperación de contraseña para {Email}", email);

    var user = await db.Users.SingleOrDefaultAsync(u => u.Email == email);

    if (user is null || !user.Enabled)
    {
        // Por seguridad, siempre responder éxito
        logger.LogWarning("Solicitud de recuperación para email no existente o deshabilitado: {Email}", email);
        return Ok(new ForgotPasswordResponse(
            true, 
            "Si el email existe, recibirás un código de verificación.", 
            null
        ));
    }

    // Generar código de 6 dígitos
    var token = resetTokenSvc.GenerateToken();
    
    // Guardar en caché
    resetTokenSvc.SaveToken(token, user.Id);
    
    logger.LogInformation("Código de recuperación generado para {Email}: {Token}", email, token);

    // Enviar email
    try
    {
        await emailSvc.SendPasswordResetEmailAsync(user.Email, token);
        logger.LogInformation("Email de recuperación enviado a {Email}", email);
    }
    catch (Exception ex)
    {
        logger.LogError(ex, "Error al enviar email de recuperación a {Email}", email);
        return StatusCode(500, new ForgotPasswordResponse(
            false,
            null,
            "Error al enviar el correo. Intenta nuevamente."
        ));
    }

    return Ok(new ForgotPasswordResponse(
        true,
        "Código de verificación enviado a tu correo.",
        null
    ));
}

[HttpPost("reset-password")]
[AllowAnonymous]
public async Task<IActionResult> ResetPassword(
    [FromBody] ForgotPasswordResetRequest req,
    [FromServices] Services.ResetTokenService resetTokenSvc)
{
    var token = (req.Token ?? "").Trim();
    var email = (req.Email ?? "").Trim().ToLowerInvariant();
    var newPassword = req.NewPassword ?? "";

    logger.LogInformation("Intento de reset de contraseña para {Email} con token {TokenPrefix}...", 
        email, token.Length > 3 ? token.Substring(0, 3) : "***");

    // Validar token
    var userId = resetTokenSvc.ValidateAndGetUserId(token);

    if (userId == null)
    {
        logger.LogWarning("Token inválido o expirado: {Token}", token);
        return BadRequest(new ForgotPasswordResponse(
            false,
            null,
            "Código inválido o expirado."
        ));
    }

    // Validar usuario
    var user = await db.Users.FindAsync(userId.Value);

    if (user is null || user.Email != email || !user.Enabled)
    {
        logger.LogWarning("Usuario no encontrado, email no coincide o deshabilitado para UserId: {UserId}", userId);
        return BadRequest(new ForgotPasswordResponse(
            false,
            null,
            "Código inválido."
        ));
    }

    // Validar longitud de contraseña
    if (newPassword.Length < 6)
    {
        return BadRequest(new ForgotPasswordResponse(
            false,
            null,
            "La contraseña debe tener al menos 6 caracteres."
        ));
    }

    // Actualizar contraseña
    try
    {
        user.PasswordHash = BCrypt.Net.BCrypt.HashPassword(newPassword);
        await db.SaveChangesAsync();

        // Eliminar token usado
        resetTokenSvc.RemoveToken(token);

        logger.LogInformation("Contraseña reseteada exitosamente para {Email} (UserId: {UserId})", 
            email, user.Id);

        return Ok(new ForgotPasswordResponse(
            true,
            "Contraseña actualizada correctamente.",
            null
        ));
    }
    catch (Exception ex)
    {
        logger.LogError(ex, "Error al actualizar contraseña para {Email}", email);
        return StatusCode(500, new ForgotPasswordResponse(
            false,
            null,
            "Error al actualizar la contraseña."
        ));
    }
}



// ========================================
// REGISTRO DE USUARIOS - COPIAR ESTE CÓDIGO
// Agregar al final de AuthController.cs (antes del cierre de clase)
// ========================================

[HttpPost("register")]
[AllowAnonymous]
public async Task<IActionResult> Register(
    [FromBody] RegisterRequest req,
    [FromServices] Services.ResetTokenService tokenSvc,
    [FromServices] Services.IEmailService emailSvc)
{
    var email = (req.Email ?? "").Trim().ToLowerInvariant();
    logger.LogInformation("Solicitud de registro para {Email}", email);

    var existingUser = await db.Users.SingleOrDefaultAsync(u => u.Email == email);

    if (existingUser != null)
    {
        logger.LogWarning("Email ya registrado: {Email}", email);
        return BadRequest(new RegisterResponse(false, null, "El email ya está registrado."));
    }

    var token = tokenSvc.GenerateToken();
    
    var tempData = new
    {
        Email = email,
        FullName = req.FullName ?? "",
        Password = req.Password ?? "",
        Empresa = req.Empresa ?? ""
    };
    
    var jsonData = System.Text.Json.JsonSerializer.Serialize(tempData);
    tokenSvc.SaveTokenWithData($"register:{token}", jsonData);
    
    logger.LogInformation("Código de verificación: {Token} para {Email}", token, email);

    try
    {
        await emailSvc.SendRegistrationEmailAsync(email, token);
        logger.LogInformation("Email de verificación enviado");
    }
    catch (Exception ex)
    {
        logger.LogError(ex, "Error enviando email");
        return StatusCode(500, new RegisterResponse(false, null, "Error al enviar el correo."));
    }

    return Ok(new RegisterResponse(true, "Código enviado a tu correo.", null));
}

[HttpPost("verify-email")]
[AllowAnonymous]
public async Task<IActionResult> VerifyEmail(
    [FromBody] VerifyEmailRequest req,
    [FromServices] Services.ResetTokenService tokenSvc)
{
    var token = (req.Token ?? "").Trim();
    var email = (req.Email ?? "").Trim().ToLowerInvariant();

    logger.LogInformation("Verificación de email: {Email}", email);

    var jsonData = tokenSvc.GetTokenData($"register:{token}");

    if (jsonData == null)
    {
        logger.LogWarning("Token inválido o expirado");
        return BadRequest(new RegisterResponse(false, null, "Código inválido o expirado."));
    }

    var data = System.Text.Json.JsonSerializer.Deserialize<System.Text.Json.JsonElement>(jsonData);
    var storedEmail = data.GetProperty("Email").GetString();

    if (storedEmail != email)
    {
        logger.LogWarning("Email no coincide");
        return BadRequest(new RegisterResponse(false, null, "Código inválido."));
    }

    var existingUser = await db.Users.SingleOrDefaultAsync(u => u.Email == email);
    if (existingUser != null)
    {
        return BadRequest(new RegisterResponse(false, null, "El email ya está registrado."));
    }

    try
    {
        var fullName = data.GetProperty("FullName").GetString() ?? "";
        var password = data.GetProperty("Password").GetString() ?? "";
        var empresa = data.GetProperty("Empresa").GetString();

        var newUser = new GestionTime.Domain.Auth.User
        {
            Id = Guid.NewGuid(),
            Email = email,
            PasswordHash = BCrypt.Net.BCrypt.HashPassword(password),
            FullName = fullName,
            Enabled = true,
            
        };

        db.Users.Add(newUser);

        var userRole = await db.Roles.SingleOrDefaultAsync(r => r.Name == "User");
        if (userRole != null)
        {
            db.UserRoles.Add(new GestionTime.Domain.Auth.UserRole
            {
                UserId = newUser.Id,
                RoleId = userRole.Id
            });
        }

        await db.SaveChangesAsync();
        tokenSvc.RemoveTokenByKey($"register:{token}");

        logger.LogInformation("Usuario registrado: {Email}", email);

        return Ok(new RegisterResponse(true, "Registro exitoso. Ya puedes iniciar sesión.", null));
    }
    catch (Exception ex)
    {
        logger.LogError(ex, "Error creando usuario");
        return StatusCode(500, new RegisterResponse(false, null, "Error al crear el usuario."));
    }
}

}
